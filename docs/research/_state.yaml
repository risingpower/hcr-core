# Research State
# Machine-readable current state for session continuity
#
# Update this at session end and read at session start.

version: "1.0"
last_updated: "2026-02-15"
last_session: "2026-02-15"

# Current focus
current:
  phase: "validation"  # discovery | research | implementation | validation
  focus: "First HCR evaluation complete. nDCG=0.345 vs flat+CE=0.835. Root cause identified: level 1 routing epsilon=0.46. Tree too shallow (depth=2, 4 branches). Need to test deeper/wider tree configs."
  blockers: []

# Research briefs status
briefs:
  active: []
  completed:
    - id: "RB-001"
      title: "Prior art survey"
      completed: "2026-02-13"
      key_finding: "12+ systems in the space since 2024. Hierarchical retrieval outperforms flat RAG on complex tasks (2-20pp gains). LATTICE is closest to HCR. No system targets hard token budgets. RAPTOR collapsed-tree result challenges strict top-down traversal."
    - id: "RB-002"
      title: "Theoretical basis: elimination vs similarity"
      completed: "2026-02-13"
      key_finding: "Strict top-down elimination is theoretically fragile — error compounds as (1-ε)^d. RAPTOR collapsed-tree result is structurally predicted, not anomalous. Hybrid coarse-to-fine (shallow elimination + flat search within survivors) is theoretically optimal. H1 needs reframing from 'elimination > similarity' to 'hierarchical coarse-to-fine with token budgets > flat retrieval'."
    - id: "RB-003"
      title: "Scoring mechanics"
      completed: "2026-02-13"
      key_finding: "Cascade architecture (hybrid BM25+dense → cross-encoder) achieves ε ≈ 0.01–0.02 per level at ~40–80ms. Strict admissibility impossible for semantic relevance. Path-relevance EMA is higher leverage than per-node scoring. Summary quality is #1 upstream factor. AdaGReS submodular knapsack for token-budget selection. H1c → 75%."
    - id: "RB-004"
      title: "Tree construction"
      completed: "2026-02-13"
      key_finding: "Four-source convergence on construction recipe: top-down divisive clustering (bisecting k-means, d=2–3, b∈[6,15]) + LLM contrastive routing summaries + soft assignment (1–3 parents per leaf). Routing summaries are a distinct artifact class: {theme, includes, excludes, key_entities, key_terms}. Gemini adds Q-STRUM Debate for adversarial contrastive generation, depth-variable summary formatting (contrastive prose at L1, keyword arrays + multi-vector at L2), Schema Entropy Bound and Sibling Distinctiveness (BM25 softmax) as concrete tree quality metrics, and EraRAG LSH hyperplanes as alternative partitioning with deterministic incremental maintenance. Cross-branch defense requires five layers. No routing-specific tree quality metric in literature — genuine research gap. H1b → 80%."
    - id: "RB-005"
      title: "Failure modes"
      completed: "2026-02-13"
      key_finding: "No architectural showstopper. 26 failure modes identified across all pipeline stages. Overall expected failure rate: 10–20%. Top residual risks: (1) DPI information loss for detail queries, (2) budget impossibility for aggregation/listing queries, (3) beam collapse without diversity enforcement. Three design changes needed: beam diversity, collapsed-tree as co-primary, external source handling. Entity cross-links elevated to primary mechanism for dominant query type (entity-centric). Transition period (small corpus) is highest-risk deployment phase."
    - id: "RB-006"
      title: "Benchmark design"
      completed: "2026-02-13"
      key_finding: "Four-source convergence on benchmark design. Hybrid corpus (50K–100K chunks from GitLab handbook + EnronQA + synthetic injectors). 300–400 stratified queries with budget-feasibility labels. 7 core metrics led by per-level routing accuracy ε (never measured in any system) and answer sufficiency under token constraint. 4 baselines (BM25, hybrid flat, flat+CE as kill baseline, RAPTOR). Fail-fast sequence with kill criteria at each step. MVB costs $15–30 in LLM API calls. Success criteria: HCR@400 ≥ flat@400 + 5pp, ε ≤ 0.03 per level, dual-path ≥ single-path + 3pp. Kill: flat+CE beats HCR at full corpus with significance."

# Baseline results (2026-02-15)
baseline_results:
  bm25:
    ndcg_at_10: 0.705
    recall_at_10: 0.82
    mrr: 0.669
    mean_tokens: 333
  hybrid_rrf:
    ndcg_at_10: 0.719
    recall_at_10: 0.90
    mrr: 0.662
    mean_tokens: 343
  flat_ce:
    ndcg_at_10: 0.835
    recall_at_10: 0.94
    mrr: 0.803
    mean_tokens: 354
  notes: "IR metrics computed on full ranked list (top-50). Token metrics on 400-token packed result. Median chunk ~470 tokens, so packing yields 0-1 chunks per query. Flat+CE is kill baseline. Results in benchmark/results/baseline_results.json (gitignored)."

# HCR results (2026-02-15, depth=2, branching=10)
hcr_results:
  config_v1:
    tree_depth: 2
    branching: 10
    beam_width: 3
    actual_branches: 4
    ndcg_at_10: 0.345
    recall_at_10: 0.36
    mrr: 0.340
    mean_tokens: 161
    epsilon_level_0: 0.000
    epsilon_level_1: 0.460
    epsilon_level_2: 0.640
    sibling_distinctiveness: 0.690
    notes: "Level 1 routing is the bottleneck. 46% of queries routed to wrong branch. Cross-encoder gives all branches ~-11 score for specific queries — summaries too coarse. Need deeper tree or more branches."

# Implementation phases completed
implementation:
  phases_complete:
    - "Phase 1: Core types (Pydantic models)"
    - "Phase 2: Corpus pipeline (chunker, loader, embedder)"
    - "Phase 3: Index infrastructure (BM25, vector, hybrid)"
    - "Phase 4: LLM client + caching"
    - "Phase 5: Retrieval baselines (BM25, hybrid, flat+CE)"
    - "Phase 6: Evaluation metrics (epsilon, sufficiency, IR)"
    - "Phase 7: Query suite + benchmark runner"
    - "Phase 9: HCR core (tree builder, beam traversal, collapsed retrieval, dual-path, scoring cascade)"
    - "Code review fixes"
    - "Query generator fix (JSON fence stripping, Haiku model)"
    - "Sanity check passed (all baselines operational)"
    - "Baseline evaluation fix (separate ranking from token packing)"
    - "Baseline evaluation complete (BM25, hybrid, flat+CE)"
    - "Per-category baseline analysis (scripts/analyse_baselines.py)"
    - "HCR baseline class + benchmark integration"
    - "Cascade leaf scoring fix (use chunk embeddings for leaves)"
    - "First HCR evaluation: nDCG=0.345, epsilon L1=0.46"
  test_count: 126
  mypy_status: "clean (32 source files)"
  ruff_status: "clean"

# Hypothesis summary
hypotheses:
  total: 3
  validated: 0
  invalidated: 0
  uncertain: 3
  retired: 1  # Original H1
  highest_confidence: "H1b (hybrid coarse-to-fine superiority) at 80%"
  lowest_confidence: "H1a (token efficiency) at 65%"
  notes: |
    First HCR run shows nDCG=0.345 vs flat+CE=0.835. NOT a kill signal yet —
    the tree is too shallow (depth=2, 4 branches). Root cause is level 1
    routing (epsilon=0.46). RB-003 predicted epsilon target of 0.01-0.02.
    Current epsilon=0.46 means routing summaries are not discriminative enough.
    Need to test deeper/wider configs before drawing hypothesis conclusions.

# Knowledge accumulation
knowledge:
  patterns_discovered: 1
  variants_discovered: 0
  contexts_documented: 0
  domains_documented: 0
  edge_cases: 0
  notes: |
    Pattern: "DPI summary blindness" — cross-encoder gives all branches
    ~-11 score for specific detail queries because coarse routing summaries
    don't contain the specific terms. Predicted by RB-005 failure mode #1.

# Next actions (prioritized)
next_actions:
  - "Test tree config A: depth=3, branching=8 (deeper tree, more routing levels)"
  - "Test tree config B: depth=2, branching=15 (wider tree, more specific clusters)"
  - "Compare both configs vs current depth=2/branch=10 baseline"
  - "Investigate whether collapsed-tree path compensates for beam routing failures"
  - "If improved routing: compare HCR vs baselines per-category (dpi, comparative, etc.)"
  - "If still failing: consider summary quality improvements (more specific summaries)"

# Notes for next session
notes: |
  FIRST HCR EVALUATION COMPLETE. Key findings:

  HCR RESULTS (depth=2, branching=10):
  - nDCG@10=0.345 vs flat+CE=0.835 (LOSE by 0.490)
  - Recall@10=0.36 vs flat+CE=0.94
  - Mean tokens: 161 vs 354 (HCR uses fewer — token efficiency works)
  - Epsilon: L0=0.00, L1=0.46, L2=0.64

  ROOT CAUSE: Level 1 routing epsilon=0.46.
  - Only 4 branches at depth=2 with 315 chunks → ~80 chunks per branch
  - Routing summaries too coarse for specific queries
  - Cross-encoder gives all branches ~-11 score for DPI queries
  - Sibling distinctiveness is fine (0.69 > 0.15 kill threshold)

  BUG FIXED THIS SESSION:
  - Cascade was giving leaves score=0.0 (no summary_embedding)
  - Fixed by adding chunk_embeddings + chunk_texts fallback to ScoringCascade
  - Improved from nDCG=0.007 to 0.345

  NEXT SESSION: Test both tree configs with fresh context:
  1. Config A: depth=3, branching=8 (deeper, more routing levels)
  2. Config B: depth=2, branching=15 (wider, more specific clusters)
  Delete benchmark/results/hcr_tree.json before each run to rebuild.

  Run command: python scripts/run_benchmark.py --mode hcr
  Tree depth/branching set in run_benchmark.py:run_hcr() (lines ~324-326)

  Dependencies: pip install -e '.[dev]'
  Branch: 0215jc
